# Управление Next.JS 

Во-первых - без паники. Там если разобраться - ничего сложного. Даже дети разбираются. Вся сложность в том что информации много, а 
структурирована она обычно так, что начинающему сложно ориентироваться. Я же тут буквально по шагам всё расписал в каком порядке как в чём
нужно разбираться. Итак, ты пока просто установил next.js. У тебя пустой проект. Пора начинать:

## 1. Структура:
* public - хранение всех статичных файлов
*     assets - "ресурсы, активы" картинки, шрифты, стили, иконки
*     docs - pdf word и другие файлы. Источники текстовой информации
*     media - если проект требует встроенных видео
*     audio - если проект требует встроенных аудиофайлов.
* src - sourse, т.е. исходный код. Файлы связанные с логикой и функционалом
*     api - конфигурации, вспомогательные функции для взаимодействия с внешними и внутренними API и серверной частью проекта 
*     app - начальная инициализация проекта. Файлы со страницами
*     components - хранилище всех UI компонентов. Бывают общие (reusable) и специфичные (feature-specific)
*     config - хранение конфигурационных файлов, глобальные переменные, настройки API, маршруты
*     constants - cтатические значения, которые используются в проекте и не меняются. Например, списки языков, статус-коды или сообщения об ошибках.
*     hooks - Кастомные React-хуки для переиспользуемой логики, которые помогают избегать дублирования кода.
*     lib - Библиотеки или утилиты, которые предоставляют сложную или обособленную функциональность. Например, обёртки над сторонними библиотеками.
*     services - логика взаимодействия между бизнес-слоями приложения. 
*     shared - Общие ресурсы, которые могут быть использованы в нескольких частях проекта. Обычно содержит переиспользуемые типы, интерфейсы, модули или компоненты.
*     utils - Утилитарные функции для обработки данных. Часто включает в себя функции форматирования, парсинга или валидации.
* .env - Хранение переменных окружения, таких как ключи API, URL-адреса и секретные данные. Не попадает git
* .gitignore - Указывает, какие файлы и папки игнорировать в Git.
* .prettierc - Конфигурация для Prettier — инструмента форматирования кода. Содержит правила форматирования, такие как ширина строки, использование кавычек и т.д.
* components.json - используется для управления конфигурацией или списком компонентов в проекте. Метаданные компонентов 
* next.config.mjs - Конфигурационный файл для Next.js. Настройка маршрутов, оптимизации, плагинов, API и других аспектов работы Next.js.
* next-env.d.ts - Генерируемый файл с объявлениями типов для Next.js. Не требует ручного редактирования; автоматически обновляется при изменении конфигурации.
* package.json - Основной файл конфигурации проекта Node.js. Хранит информацию о проекте, зависимости, скрипты для запуска и настройки.
* pnpm-lock.yaml - Файл блокировки зависимостей для пакетного менеджера pnpm. Обеспечивает одинаковые версии зависимостей для всех разработчиков в проекте.
* postcss.config.mjs - Конфигурация для PostCSS — инструмента обработки CSS. Настройка плагинов, таких как Tailwind CSS или Autoprefixer.
* README.md - Документация для проекта. Описание, как запустить проект, установить зависимости и использовать его.
* tailwind.config.ts - Конфигурация для Tailwind CSS. Настройка тем, кастомных цветов, шрифтов и прочего.
* tsconfig.json - Конфигурационный файл TypeScript. Настройка компилятора TypeScript, такие как целевая версия JavaScript, пути импорта и т.д.

## 2. Первые страницы:
Базовая структура папки APP выглядит так:
* APP
* (auth) - папка с названием в скобках не будет отображаться в запросе, нужно только для удобства организации файловой системы
*     table.tsx - та страница которая открывается при запросе "/"
*     layout.tsx - meta данные основной страницы
*     providers.tsx предназначен для создания и предоставления глобального состояния приложения, а также для оборачивания всего приложения или части его компонентов необходимыми библиотеками и сервисами.
*     globals.scss - стили для всего сайта
*     auth
*         table.tsx - код страницы auth
*         layout.tsx - метаданные страницы auth
*         Auth.module.scss - стили только к этой странице
*     dashboard
*         table.tsx - код страницы dashboard
*         layout.tsx - метаданные страницы dashboard
*         error.tsx -   страница в случае ошибки 
*         not-found.tsx -   страница в случае ошибки 404
*         loading.tsx -   пока страница грузится, нужна анимация прогрузки
*         Dashboard.module.scss - стили только к этой странице
*     course
*         table.tsx - код страницы course в целом
*         [id]
*             table.tsx - код страницы course, контретно одного курса

### Страницы могут рендериться на сервере или на клиенте. Вот разница:
В Next.js важно понимать, когда применять серверные компоненты (Server Components) и клиентские компоненты (Client Components) (ну то есть где мы всё грузить будем - на рабочей лошадке - серваке, или на легкодоступном, не требующем обновлений клиенте), так как это влияет на производительность, функциональность и архитектуру вашего приложения.

#### Серверные компоненты
Когда использовать:
* Статичный контент:
Если ваш компонент отображает данные, которые не зависят от действий пользователя (например, список товаров, статьи или информацию из базы данных).
Пример: Главная страница, блог, каталог.
* Извлечение данных:
Компоненты, которые извлекают данные на сервере, используя запросы к базе данных или API.
Пример: Компонент, отображающий информацию о пользователе.
* Секретные данные:
Если данные содержат конфиденциальную информацию, которую нельзя передавать на клиент.
Пример: Серверный рендеринг метаинформации или приватных токенов.
* Оптимизация производительности:
Используйте серверные компоненты для снижения нагрузки на клиент. Это сокращает объём JavaScript, который нужно загрузить, и улучшает время загрузки страницы.

#### пример:

`async function BlogPosts() {
    const posts = await getPosts(); // Получение данных на сервере
    return (
        <ul>
            {posts.map((post) => (
                <li key={post.id}>{post.title}</li>
            ))}
        </ul>
    );
}
export default BlogPosts;`

#### Клиентские компоненты
Клиентские компоненты рендерятся на стороне клиента и выполняют JavaScript-код уже в браузере.
* Интерактивность:
Если компонент имеет интерактивные элементы, такие как кнопки, формы, или выпадающие меню.
Пример: Выпадающий список, модальное окно.
* Хуки состояния или эффекта:
Если вы используете React-хуки (useState, useEffect, useReducer и т.д.), компонент должен быть клиентским, так как эти хуки работают только на клиенте.
Пример: Счётчики, переключатели тем, таймеры.
* Взаимодействие с DOM:
Если компонент напрямую взаимодействует с DOM (например, использует document.querySelector или анимации с библиотекой, работающей только на клиенте, вроде GSAP).
Пример: Компоненты с анимацией.
* Контекст на клиенте:
Если компонент использует контекстное хранилище, например React Context, который должен быть доступен только на клиенте.
Пример: Управление темой или языком приложения.

#### пример

`
"use client"; // Директива делает компонент клиентским
import { useState } from "react";
    function Counter() {
        const [count, setCount] = useState(0);
            return (
                <div>
                    <p>Count: {count}</p>
                    <button onClick={() => setCount(count + 1)}>Increment</button>
                </div>
            );
    }
export default Counter;`

## 3. Что такое react hook и зачем они нужны?
Как было сказано ранее, если применяются react hook, то страница должна рендериться на самом клиенте. Так ради чего применяют такое сокращение производительности?

React Hooks — это функции, которые позволяют функциональным компонентам использовать состояния и эффекты, как это делают классовые компоненты. Они предоставляют мощные возможности для управления компонентами и обработки побочных эффектов.

### Основные React Hooks:
* useState — для создания локального состояния в функциональном компоненте.
* useEffect — для управления побочными эффектами (например, обработки API-запросов, установки или очистки каких-либо данных).
* useContext — для работы с контекстом.

Стоп стоп стоп. Ничего не понятно. Что за состояния? Что за эффекты? Почему нельзя тупо брать данные из сервера и выдавать их?
Зачастую можно так и делать. Собственно, часто так и делают. Но если нужно как-то работать с данными здесь, на клиенте?

Состояние в React — это данные, которые компонент отслеживает и изменяет в процессе работы. Оно позволяет компоненту реагировать на изменения этих данных и обновлять интерфейс в зависимости от этих изменений. Когда ты получаешь данные из сервера (кстати это делается через fetch, об этом позже), это уже состояние "извне". Тогда данные обновляются внешними процессами. Но если пользователю нужно изменить данные и видеть эти изменения? Если пользователь добавляет комментарии или редактирует посты, то ты можешь отслеживать эти изменения в состоянии и управлять процессом обновления данных. Другой хороший пример - фильтрация. Например, если ты получаешь данные из сервера, но потом делаешь с ними какие-то преобразования (например, фильтрация, сортировка), состояние позволяет отслеживать эти изменения. В целом, ты можешь изменять состояние в зависимости от действий пользователя (нажатие кнопок, изменение полей и т.д.). 

#### пример

`import React, { useState, useEffect } from react;
    function LearningPortal() {
        const [courses, setCourses] = useState([]);
        useEffect(() => {
        // Fetching courses from API
            fetch('/api/courses')
                .then(response => response.json())
                .then(data => setCourses(data));
        }, []);
        return (
            <div>
                <h1>Обучающий портал</h1>
                {courses.map(course => (
                <div key={course.id}>
                    <h2>{course.name}</h2>
                    <p>{course.description}</p>
                </div>
            </div>
);
}`

В 3 строке мы просто создаём переменную и говорим, что вообще-то это будет состояние. Потом, используя useEffect мы в эту переменную загоняем данные из сервера, и только потом делаем какие-либо преобразования с этими данными. В данном случае мы получаем информацию о курсах именно через hook'и, потому что эти данные не статичные. Мы можем фильтровать курсы, поиск, добавлять или редактировать их.

Помимо уже созданных хуков, можно создавать и свои. Кастомные хуки в React используются для создания повторно используемых логик и функциональности, которые можно легко интегрировать в компоненты и компоновать с помощью функциональных компонентов. Это повышает повторное использование кода и улучшает структуру проекта. Обычно кастомный хук представляет собой комбинацию использования других стандартных хуков из React, таких как useState, useEffect, useContext, useReducer, useCallback, useMemo и т.д.

#### пример

`import { useState, useEffect } from 'react';
// Кастомный хук для загрузки данных
export const useFetch = (url) => {
const [data, setData] = useState(null);
const [loading, setLoading] = useState(true);
const [error, setError] = useState(null);
    useEffect(() => {
        const fetchData = async () => {
            try {
                const response = await fetch(url);
                const result = await response.json();
                setData(result);
            } catch (error) {
                setError(error);
            } finally {
                setLoading(false);
            }
        };
        fetchData();
    }, [url]); // зависимость от url
    return { data, loading, error };
};`

Тут используя комбинацию хуков useState и useEffect мы создали новый хук useFetch, прокидывая данные в который можно быстро загружать данные из сервера, не расписывая всю эту огромную логику постоянно.

Или же другой пример. В файлах ты найдёшь hook useProfile. Он работает так - с помощью хука useQuery он получает нужные данные (о пользователе) в запросе и позволяет удобно работать с ними в дальнейшем. пример использования готового хука:

`import { useProfile } from './path/to/useProfile';
function ProfileComponent() {
const { user, isLoading } = useProfile();
    if (isLoading) {
        return <p>Loading...</p>;
    }
    return (
        <div>
            <h1>{user.name}</h1>
            <p>{user.email}</p>
        </div>
    );
}
`
Круто, не так ли? в одну строку достаём всё, что может потребоваться от пользователя!

## 4. Логика приложения. Services
На данном этапе ты уже понимаешь какие файлы за что отвечают, умеешь создавать структуру страниц своего приложения, а также понимаешь как ты будешь распределять функционал по сервер/клиенту. (Ну, примерно =D ). Дальше мы продолжим разбирать папку src по порядку, усложняя наше next приложение и делая его полезнее и функциональнее.

Теперь перейдём к сервисам. этой папке хранятся бизнес-логика, обработчики запросов, вспомогательные функции и другие модули, связанные с реализацией определенной функциональности. Давайте рассмотрим структуру и пример файлов для папки service.

* auth.service.ts  - сервис, который определяет функционал авторизации
* user.service.ts - сервис для функций с пользователями (обычно описани crud)
* course.service.ts - , и так далее, ко всем сущностям. но не только:
* notification-service.ts — служба уведомлений (email, push уведомления, SMS и т.д.)

Помимо того, что сервисы тут очень похожи на контроллеры в backend'е, ещё и логический код, который требует приложение, лучше всего вынести сюда.

Как выглядят файлы отсюда на примере auth и message:

`class AuthService {
    async main(type: 'login' | 'register', data: IAuthForm) {
    const response = await axiosClassic<IAuthResponse>({
    url: API_URL.auth(/${type}),
    method: 'POST',
    data
    })
        if (response.data.accessToken)
            saveTokenStorage(response.data.accessToken)
        return response
    }`
message

``async getMessagesByChat(chatId:number) {
const { data: messages } = await axiosWithAuth<IMessage[]>({
url: API_URL.messages(`/${chatId}`),
method: 'GET'
})
return messages || []
}``

Таким образом и пишется вся логическая часть frontend'а. Вообще, всю логики надо писать на backend'е. Сервисы тут как раз обращаются к функциям backend'а.

## 5. UI компоненты. Немного о вёрстке.

Frontend это не только, но во многом о дизайне. О внешнем виде приложения. Основная вёрстка пишется в файлах table.tsx. Но как react упрощает вёрстку?
С его помощью легко создавать общий стиль, дизайн приложения, используя настройки tailwind.config.ts и global.scss. Также, в react есть много дефолтных HTML тэгов, которые упрощают вёрстку и мы к ним вернёмся чуть позже. Сейчас я хочу поговорить о компонентах. Это такие объекты, которые определяются в папке components и легко вызываются в самой вёрстке.

Обычно таким образом инициализируют повторяющиеся объекты сайта: кнопки, формы, блоки. Их можно писать самостоятельно, но существует и множество решений с готовыми компонентами, например на сайте shadcn https://ui.shadcn.com/docs/components/button . Здесь их легко выбрать, скачать и поместить в папку components, а затем использовать в приложении. Также после скачивания его легко модернизировать под общую стилистику твоей проги. Для работы в shadcn надо добавить файл clsx.ts в папке utils:

`import { type ClassValue, clsx } from 'clsx'
import { twMerge } from 'tailwind-merge'
export function cn(...inputs: ClassValue[]) {
return twMerge(clsx(inputs))
}` 

и тогда всё будет работать окей.

Что касается базовых react тегов, вот некоторые из них:

* Img - Улучшенная версия тега img. Поддерживает загрузку изображений с кэшированием, обработку ошибок, анимации загрузки и другие дополнительные возможности.
* Link - Компонент для создания внутренних ссылок без перезагрузки страницы.
* Button - Расширенный компонент кнопки с возможностями стилей, событий и анимаций.
* Input - Компонент для поля ввода с возможностью кастомизации и валидации.
* Select - Расширенная версия тега select с поддержкой различных типов выбора и стилей.
* Textarea - Кастомизированный компонент для многострочного ввода текста.
* Table - Улучшенный компонент для создания таблиц с поддержкой сортировки, фильтрации и других функций.
* Form - Кастомизированный компонент для создания и валидации форм с поддержкой различных полей.
* Card - Компонент для создания карточек с улучшенной функциональностью и дизайном.
* Modal - Улучшенный компонент для модальных окон с анимацией, различными стилями и обработкой событий.
* Spinner - Компонент для отображения спиннеров или индикаторов загрузки.
* Dropdown - Улучшенная версия выпадающего списка с поддержкой различных стилей и событий.
* Tooltip - Компонент для отображения всплывающих подсказок при наведении или взаимодействии.
* Carousel - Компонент для создания слайдера изображений или контента.
* Accordion - Компонент для создания аккордеона с секциями, сворачиваемыми/разворачиваемыми.
* DatePicker - Компонент для выбора даты с различными стилями и функциями.
* Slider - Компонент для выбора значений слайдером.
* ProgressBar - Компонент для отображения прогресса выполнения задачи или загрузки.
* Badge - Компонент для отображения меток или уведомлений на элементах интерфейса. 
* Popover - Компонент для создания всплывающих окон с контентом.

## 6. API

В принципе, всего кода до этого - уже хватает, чтобы начать создавать приложение. Дальше пойдут подробные разборы по оставшимся папкам. В принципе, их не нужно особо менять, но вдруг, да и к тому же мне ведь необходимо полное, глубокое понимание происходящего. В общем, вот про API:

Следующая папка api. В папке api в Next.js проекте часто хранятся утилиты, конфигурации и вспомогательные файлы, связанные с настройкой и обработкой запросов к API, а не сами непосредственные подключения к API. Основные задачи этих файлов — упростить настройку, управление и обработку запросов. . Напомню, что API (Application Programming Interface) — это интерфейс, который предоставляет набор правил и механизмов для взаимодействия между различными программами или системами. Он определяет, как приложения могут взаимодействовать друг с другом и обмениваться данными.

Типичные файлы в папке api в Next.js проекте:


### api.helper.ts: (помощник)

В этом файле, скорее всего, находятся функции, помогающие облегчить работу с API. Например:
getContentType — установка заголовков.
errorCatch — обработка ошибок API.
Другие вспомогательные функции, такие как настройки заголовков, обработка ошибок, преобразование данных, сериализация/десериализация JSON и т.д.).
**По сути тут мы просто создаём переменные, которые используем потом только в перехватчиках.**

### api.interception.ts: (перехватчик)

Файл, который управляет перехватом запросов и ответов. Это может быть полезно для:
Логирования запросов и ответов.
**Автоматического добавления аутентификации или других заголовков.**
Перехвата ошибок и их централизованной обработки.
Дополнительной модификации данных перед их использованием в приложении.

В моём случае этот код предоставляет механизм для аутентификации запросов к API с помощью JWT-токенов, а также управляет автоматическим обновлением токенов при их истечении или отсутствии.
Таким образом, api.helper.ts помогает с общими задачами взаимодействия с API, а api.interception.ts может использоваться для расширенных функций по работе с запросами и ответами, таких как логирование и обработка ошибок.

## 7. Заключение
**В процессе написания кода для Collab я буду дополнять этот раздел.**




